package Config::Resolver::Plugin::SSM;

use strict;
use warnings;

use Amazon::Credentials;
use Amazon::API::SSM;
use Carp;
use English qw(-no_match_vars);
use Scalar::Util qw(reftype);
use Data::Dumper;
use Config::Resolver::Utils qw(to_boolean is_array);

our @OPTIONS = qw(order debug ssm profile credentials log_level endpoint_url warning_level load );

__PACKAGE__->follow_best_practice;
__PACKAGE__->mk_accessors(@OPTIONS);

our $PROTOCOL = 'ssm';

our $VERSION = '@PACKAGE_VERSION@';

use parent qw( Class::Accessor::Fast );

use Readonly;

Readonly::Scalar our $TRUE  => 1;
Readonly::Scalar our $FALSE => 0;
Readonly::Scalar our $EMPTY => q{};

########################################################################
sub new {
########################################################################
  my ( $class, @args ) = @_;

  my $options = ref $args[0] ? $args[0] : {@args};

  my %plugin_options;
  @plugin_options{@OPTIONS} = @{$options}{@OPTIONS};

  my $self = $class->SUPER::new( \%plugin_options );

  $self->init;

  return $self;
}

########################################################################
sub init {
########################################################################
  my ($self) = @_;

  my $order = $self->get_order // [qw(env container role file)];

  if ( !is_array($order) ) {
    $order =~ s/\s//xsm;
    $order = [ split /[,]/xsm, $order ];
  }

  my $credentials = $self->get_credentials;

  if ( !$credentials ) {
    $credentials = Amazon::Credentials->new(
      { debug              => $self->get_debug,
        order              => $order,
        imdsv2             => $ENV{IMDSV2_ENABLED} // $TRUE,
        no_passkey_warning => $TRUE,
        profile            => $self->get_profile,
      }
    );
  }

  $self->set_credentials($credentials);

  my $ssm = Amazon::API::SSM->new(
    { credentials => $credentials,
      debug       => $self->get_debug,
      log_level   => $self->get_log_level // 'info',
      $self->get_endpoint_url ? ( url => $self->get_endpoint_url ) : (),
    }
  );

  $self->set_ssm($ssm);

  if ( $self->get_load ) {
    $self->load;
  }

  return;
}

########################################################################
sub resolve {
########################################################################
  my ( $self, $path, $parameters ) = @_;

  return $self->get_ssm_parameter( $path, $TRUE );
}

########################################################################
sub get_ssm_parameter {
########################################################################
  my ( $self, $parameter, $with_decryption ) = @_;

  if ( $parameter !~ /^\//xsm ) {
    $parameter = "/$parameter";
  }

  my $value = eval {
    my $rsp = $self->get_ssm->GetParameter(
      { Name           => $parameter,
        WithDecryption => to_boolean( $with_decryption // $TRUE ) ? 'true' : 'false',
      }
    );

    return $rsp->{Parameter}->{Value};
  };

  my $err = $EVAL_ERROR;

  die $err
    if $err && !$self->get_warning_level eq 'warn';

  if ($err) {
    warn $err;
  }

  return $value;
}

########################################################################
sub load {
########################################################################
  my ($self) = @_;

  my $file = $self->get_load;

  if ( !-t STDIN ) {
    $file = q{-};
  }

  croak "ERROR: cannot load file - $file not found\n"
    if $file ne q{-} && !-e $file;

  croak "ERROR: load file must be .ya?ml or .json\n"
    if $file ne q{-} && $file !~ /[.](?:ya?ml|json)$/xsm;

  my $parameters = fetch_parameters($file);

  foreach my $key ( keys %{$parameters} ) {
    my $value           = $parameters->{$key}->{value};
    my $with_encryption = $parameters->{$key}->{encrypted};

    $self->put_ssm_parameter( $key, $value, $with_encryption );
  }

  return;
}

########################################################################
sub fetch_parameters {
########################################################################
  my ($file) = @_;

  if ( $file eq q{-} ) {
    local $RS = undef;

    my $content = <>;

    require YAML::Tiny;
    YAML::Tiny->import('Load');

    my $parameters = eval { Load($content); };

    return $parameters
      if ref $parameters;

    require JSON;
    JSON->import('from_json');

    # we probably want this to blow up if the input is not valid JSON
    return from_json($content);
  }

  ######################################################################
  # file must be either .ya?ml or .json
  ######################################################################
  if ( $file =~ /[.]ya?ml$/xsm ) {
    require YAML::Tiny;

    YAML::Tiny->import('LoadFile');
    return LoadFile($file);
  }

  return
    if $file !~ /[.]json$/xsm;

  require JSON;
  JSON->import('from_json');

  local $RS = undef;

  open my $fh, '<', $file
    or croak "ERROR: could not load $file\n$OS_ERROR";

  my $content = <>;

  close $fh;

  return from_json($content);
}

########################################################################
sub put_ssm_parameter {
########################################################################
  my ( $self, $parameter, $value, $with_encryption ) = @_;

  $self->get_ssm->PutParameter(
    { Name      => $parameter,
      Value     => "$value",
      Overwrite => 'true',
      Type      => to_boolean( $with_encryption // $FALSE ) ? 'SecureString' : 'String',
    }
  );

  return $value;
}

1;

__END__

=pod

=head1 NAME

Config::Resolver::Plugin::SSM - AWS Parameter Store backend for Config::Resolver

=head1 SYNOPSIS

 # In your main application
 use Config::Resolver;
 
 # This plugin is loaded automatically by Config::Resolver
 my $resolver = Config::Resolver->new(
     plugins => [ 'SSM' ],
     
     # Options are passed to the plugin
     endpoint_url => 'http://localstack:4566',
     debug        => 1,
 );

 my $value = $resolver->resolve('ssm://my/parameter/path');

=head1 DESCRIPTION

This module is a plugin for L<Config::Resolver>. It provides a
backend handler for the C<ssm://> protocol, allowing the resolver
to fetch values from the AWS SSM Parameter Store.

It uses L<Amazon::API::SSM> and L<Amazon::Credentials> to handle
the AWS connection.

=head1 CONFIGURATION

This plugin is configured by passing a C<plugin_config> hash to the
C<Config::Resolver> C<new()> constructor. The key for this plugin's
configuration *must* be C<ssm>, as defined by its C<$PROTOCOL>
package variable.

B<Example (in your main script):>

 use Config::Resolver;
 my $resolver = Config::Resolver->new(
     plugins       => [ 'SSM' ],
     plugin_config => {
         'ssm' => {
             # ... ssm options below ...
             region       => 'us-east-1',
             endpoint_url => 'http://localhost:4566',
         }
     }
 );

This plugin accepts the following keys in its configuration hash:

=over 5

=item order

An ARRAY reference that determines the order in which
L<Amazon::Credentials> will look for your AWS credentials [cite: 905-906].
Default: C<[qw(env container role file)]>

=item credentials (optional)

An instance of L<Amazon::Credentials>. If not provided, the constructor
will create one [cite: 907-908].

=item debug

Sets debug mode for this plugin and the underlying AWS clients[cite: 907, 908].

=item endpoint_url (optional)

A custom endpoint URL for the SSM API, primarily used for
LocalStack testing.

=item log_level (optional)

Sets the log level for the underlying C<Amazon::API::SSM> client.
Default: C<'info'>

=item warning_level

Sets the warning level for parameter resolution.
Default: C<'error'>

=back

=head1 ON-DEMAND DATA SEEDING (THE C<load> OPTION)

This plugin includes a powerful feature to "seed" an SSM Parameter
Store from a local YAML or JSON file [cite: 900, 902-903]. This is
especially useful for initializing a local development environment
like LocalStack.

This feature is triggered by providing the C<load> option with a
path to a file. When the plugin is initialized, it will:

1.  Check if the C<load> option is present.
2.  If it is, it will parse the specified file[cite: 900].
3.  It will then iterate over every top-level key in the file and
    call C<PutParameter> to store its value in SSM [cite: 900-901, 906].

=head2 File Format

The seed file must be a YAML or JSON file. The file should be a
hash where each key is the full SSM parameter name, and its
value is a hash containing a C<value> and an optional C<encrypted>
flag.

B<Example C<local-secrets.yml>:**
  
  /my-app/database/host:
    value: "localhost"
  
  /my-app/database/password:
    value: "MyS3cret!"
    encrypted: true

The plugin will automatically set the SSM parameter `Type` to
C<SecureString> if C<encrypted> is true, or C<String> if it
is false or omitted[cite: 906].

=head2 Example Usage

This feature is designed to be run using C<config-resolver.pl>'s
"setup-only" execution mode (by running it without a command
like C<resolve> or C<dump>).

To load the C<local-secrets.yml> file into your LocalStack
endpoint, you would run:

  $ config-resolver.pl \
      --plugins SSM \
      --plugin ssm:load=local-secrets.yml \
      --plugin ssm:endpoint_url=http://localhost:4566

This command will:

=over 4

=item Initialize the C<SSM> plugin.

=item The plugin's C<init> method will see the C<load> flag and
execute the data seeding.

=item The C<config-resolver.pl> script will then exit cleanly because
no command was provided.

=back

=head1 METHODS

=head2 new( $options_hash_ref )

Called by C<Config::Resolver>. The constructor creates a new,
*fully initialized* plugin object. It receives a hash of
configuration options (see L<CONFIGURATION> above).

=head2 resolve( $path, $parameters )

Called by C<Config::Resolver>. Resolves the C<ssm://> placeholder.
This method will always attempt to decrypt C<SecureString> parameters.

=head2 get_ssm_parameter( $parameter_name, $with_decryption )

Retrieves a parameter from the AWS SSM Parameter Store.

=head2 put_ssm_parameter( $parameter_name, $value, $with_encryption )

Stores a value to AWS Parameter Store.

=head1 AUTHOR

Rob Lauer - <rclauer@gmail.com>

=head1 SEE ALSO

L<Amazon::API::SSM>, L<Amazon::Credentials>, L<Config::Resolver>

=cut
